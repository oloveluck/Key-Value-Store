#!/usr/bin/env python3

import sys, socket, select, time, json, random, asyncio
from typing import List, Dict

class State:
    id: str
    replicas: List
    # Persistent state on all servers
    currentTerm: int
    votedFor: str
    log: List
    leader_id: str
    # Volitile state on all servers
    commitIndex: int
    lastApplied: int
    # Volitile state on all servers
    nextIndex : Dict
    matchIndex : Dict

    def __init__(self, my_id, replica_ids):
        self.id = my_id
        self.replicas = replica_ids
        self.nextIndex = { replica: 0 for replica in replica_ids }
        self.matchIndex = { replica: 0 for replica in replica_ids }
        self.leader_id = 'FFFF'
        self.votedFor = None
        self.log = []
        self.commitIndex = self.lastApplied = self.currentTerm = 0

class RPC:
    term : int
    msg_type: str
    dst: str

    
    
class RPCFactory:
    def BuildMessage(msg) -> RPC:
        """
        Builds message from JSON response.
        """
        if msg["type"] == "rv":
            return RequestVote(msg['src'], msg['lastLogIndex'], msg['lastLogTerm'])
        elif msg['type'] == 'ae':
            return AppendEntries(msg['src'], msg['leader'], msg['prevLogIndex'], msg['prevLogTerm'], msg['leaderCommit'], msg['entries'])
        elif msg['type'] == 'aer':
            return AppendEntriesResponse(msg['src'], msg['success'], msg['term'], msg['matchIndex'])
        elif msg['type'] == 'rvr':
            return RequestVoteResponse(msg['src'], msg['voteGranted'], msg['src'], msg['term'])
        elif msg['type'] in ['get', 'put']:
            pass #TODO finish
    
class AppendEntriesResponse(RPC):
    success: bool
    matchIndex: int

    def __init__(self, src, success, term, matchIndex):
        self.dst = src
        self.success = success
        self.term = term
        self.matchIndex = matchIndex

    def toJSON(self, leader, src):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            "type": "aer",
            "success": self.success,
            'leader': leader,
            "term": self.term,
            'matchIndex': self.matchIndex })
    
    
class AppendEntries(RPC):
    leaderId : str
    prevLogIndex : int
    prevLogTerm : int
    leaderCommit: int
    entries : List

    def __init__(self, leaderId, prevLogIndex, prevLogTerm, leaderCommit, entries):
        self.leaderId = leaderId
        self.prevLogIndex = prevLogIndex
        self.prevLogTerm = prevLogTerm
        self.entries = entries
        self.leaderCommit = leaderCommit
    
    def handleMessage(self, server: Server):
        """
        Handles an AppendEntries RPC and Sends a Response
        """
        term_match = self.term  >= server.state.commitIndex
        prev_term_match = self.prevLogTerm in [server.state.log[self.prevLogIndex], None]
        success = not term_match and prev_term_match

        if not success:
            return AppendEntriesResponse(success)
        else:
            if len(server.state.log) > self.prevLogIndex:
                server.state.log = server.state.log[:self.prevLogIndex]
            server.state.log += self.entries

            if self.leaderCommit > server.state.commitIndex:
                server.state.commitIndex = min(self.leaderCommit, len(server.state.log) - 1)
        

class RequestVoteResponse(RPC):
    """
    
    """
    voteGranted: bool
    
    def __init__(self, src, term, voteGranted: bool) -> None:
        self.dst = src
        self.term = term
        self.voteGranted = voteGranted
        super().__init__()

    def handleMessage(self, server: Server):
        pass

    def toJSON(self, leader, src):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'term': self.term,
            'leader': leader,
            'voteGranted': self.voteGranted
        })
    
class RequestVote(RPC):
    candidateId : int
    lastLogIndex : int
    lastLogTerm : int

    def __init__(self, candidateId, lastLogIndex, lastLogTerm):
        self.dst = candidateId
        self.candidateId = candidateId
        self.lastLogTerm = lastLogTerm

    def handleMessage(self, server: Server) -> RequestVoteResponse:
        """
        Handles a Request Vote Message
        """
        voteGranted = self.term >= server.state.currentTerm \
            or (server.state.votedFor in [None, self.candidateId]
                and self.lastLogTerm == server.state.log[-1]["term"]) 
        return RequestVoteResponse(voteGranted)

class Controller:
    name: str
    event_loop = None
    election_timeout: asyncio.TimerHandle
    server: Server
    
    def __init__(self, event_loop, server : Server) -> None:
        self.server = server

    def restartElectionTimeout(self):
        if self.election_timeout is not None:
            self.election_timeout.cancel()
        timeout = random.randint(60, 150) / 1000
        self.server.event_loop.call_later(timeout, self.server.changeController, "candidate")


    def applyRules(self):
        if self.server.state.commitIndex > self.server.state.lastApplied:
            self.server.state.lastApplied += 1
        
        

class Leader(Controller):
    heartbeat: asyncio.TimerHandle

    def __init__(self, event_loop, server) -> None:
        super().__init__(event_loop, server)
        self.name = "leader"
        self.server = server

    def restartHeartbeat(self):
        if self.heartbeat is not None:
            self.heartbeat.cancel()
        [self.server.event_loop.create_task(self.sendAEMessage(replica)) for replica in self.server.state.replicas]
        timeout = random.randint(30, 50) / 1000
        self.server.event_loop.call_later(timeout, self.restartHeartbeat)

    def sendAEMessage(self, replica_id):
        nextIndex = self.server.state.nextIndex[replica_id]
        self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            "type": "ae",
            "term": self.server.state.term,
            "src": self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            "entries" : self.server.state.log[nextIndex:nextIndex + 50],
            "leaderCommit" : self.server.state.commitIndex,
            'prevLogindex': nextIndex - 1,
            'prevLogTerm': self.server.state.log[nextIndex - 1]['term']
        }))

    def restartElectionTimeout(self):
        print("Leaders don't have election timeout")
    
    
class Candidate(Controller):
    votesReceived: int
    
    def __init__(self, event_loop, server) -> None:
        super().__init__(event_loop, server)
        self.name = "candidate"
        self.server = server
        self.server.state.leader_id = 'FFFF' # TODO is this necessary
        self.server.state.currentTerm += 1
        self.server.state.votedFor = self.server.state.id
        self.votesReceived = 1
        [self.server.event_loop.create_task(self.sendRV(replica_id)) for replica_id in self.server.state.replicas]
        self.restartElectionTimeout()

    def sendRV(self, replica_id):
        self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            'src': self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            'term': self.server.state.currentTerm,
            'type': 'rv',
            'lastLogIndex': len(self.server.state.log) - 1,
            'lastLogTerm': self.server.state.log[-1]['term']
        }).encode())

class Follower(Controller):
    
    def __init__(self, event_loop, server) -> None:
        super().__init__(event_loop, server)
        self.name = "follower"
        self.server = server
        self.restartElectionTimeout()

        

class Servers:
    state: State
    controller: Controller
    rpcfactory: RPCFactory
    sock: socket.socket
    data: Dict
    event_loop = None

    def __init__(self, my_id, replicas, sock):
        self.id = my_id
        self.state = State(my_id, replicas)
        self.rpcfactory = RPCFactory()
        self.sock = sock
        self.event_loop = asyncio.get_event_loop()
        asyncio.get_event_loop().create_task(self.receive())
        self.controller = Follower(self.event_loop, self)

    async def receive(self):
        msg_raw = await self.event_loop.sock_recv(self.sock, 32768)
        if len(msg_raw) != 0:
            msg = json.loads(msg_raw)
            rpc = self.rpcfactory.BuildMessage(msg)
            resp = rpc.handleMessage(self.state)
            self.event_loop.sock_sendall(self.sock, resp.toJSON(self.state.leader_id, self.state.id))
            
            
        asyncio.get_event_loop().create_task(self.receive())

    async def changeController(self, controller_type: str):
        if controller_type == "candidate":
            self.controller = Candidate(self.event_loop, self)
        

if __name__ == "__main__":
    # Your ID number
	my_id = sys.argv[1]

	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]

	# Connect to the network. All messages to/from other replicas and clients will
	# occur over this socket
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	sock.setblocking(0)
	sock.connect(my_id)
    
	Server(my_id, replica_ids, sock)
