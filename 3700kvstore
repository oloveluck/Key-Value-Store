#!/usr/bin/env python3

import sys, socket, select, time, json, random, asyncio, math
from typing import List, Dict

DEBUG = True 

class State:
    id: str
    replicas: List
    # Persistent state on all servers
    currentTerm: int
    votedFor: str
    log: List
    leader_id: str
    # Volitile state on all servers
    commitIndex: int
    lastApplied: int
    # Volitile state on all servers
    nextIndex : Dict
    matchIndex : Dict

    def __init__(self, my_id, replica_ids):
        self.id = my_id
        self.replicas = replica_ids
        self.leader_id = 'FFFF'
        self.votedFor = None
        self.log = []
        self.commitIndex = self.lastApplied = self.currentTerm = 0

class RPC:
    dst: str
    msg_type: str

    def __init__(self, dst, msg_type):
        self.dst = dst
        self.msg_type = msg_type

class ClientRPC(RPC):
    MID: str
    key: str
    
    def __init__(self, dst, msg_type, MID, key):
        super().__init__(dst, msg_type)
        self.MID = MID
        self.key = key

class ServerRPC(RPC):
    term : int

    def __init__(self, term, dst, msg_type):
        super().__init__(dst, msg_type)
        self.term = term
        
    def handleMessage(self, server):
        if self.term > server.state.currentTerm: # if message term is greater than the server's term
            server.state.currentTerm = self.term
            server.state.votedFor = None
            server.changeController("follower")
            # server.state.leader_id = self.dst
            #print(server.state.id, " changed to a follower")

class RPCFactory:
    def BuildMessage(self, msg) -> RPC:
        """
        Builds message from JSON response.
        """
        if msg["type"] == "rv":
            return RequestVote(msg['src'], msg['lastLogIndex'], msg['lastLogTerm'], msg['term'])
        elif msg['type'] == 'ae':
                  return AppendEntries(msg['src'], msg['prevLogIndex'], msg['prevLogTerm'], msg['leaderCommit'], msg['entries'], msg['term'])
        elif msg['type'] == 'aer':
            return AppendEntriesResponse(msg['src'], msg['success'], msg['term'], msg['matchIndex'])
        elif msg['type'] == 'rvr':
            return RequestVoteResponse(msg['src'], msg['term'], msg['voteGranted'])
        elif msg['type'] == 'get':
            return Get(msg['src'], msg['key'], msg['MID'])
        elif msg['type'] == 'put':
            return Put(msg['src'], msg['key'], msg['value'], msg['MID'])
        else:
            raise RuntimeError("Got MSG Type:" + msg['type'])

class ForwardMessage(ClientRPC):
    def __init__(self, dst, MID):
        super().__init__(dst, 'redirect', MID, None)

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'leader': leader,
            'MID': self.MID,
            'type': self.msg_type,
        })

class Get(ClientRPC):
    """
    A Get request
    """
    def __init__(self, src, key, MID):
        super().__init__(src, "get", MID, key)

    def handleMessage(self, server):
        if server.controller.name != 'leader':
            ## forward message to the leader
            return [ForwardMessage(self.dst, self.MID)]
        else:
            return [GetResponse(self.MID, self.dst, self.key, server.data[self.key] if self.key in server.data else "")]

class GetResponse(ClientRPC):
    value: str
    def __init__(self, mid: str, dst: str, key: str, value: str):
        super().__init__(dst, "ok", mid, key)
        self.value = value

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            "leader": leader,
            "type" : self.msg_type,
            "MID" : self.MID,
            "value" : self.value
        })

class Put(ClientRPC):
    
    def __init__(self, src, key, value, MID):
        super().__init__(src, 'put', MID, key)
        self.value = value

    def handleMessage(self, server):
        if server.controller.name == 'leader':
            server.state.log.append({ 
                'entryType': 'put', 
                'term': server.state.currentTerm,
                'index': len(server.state.log), 
                'data': {
                    "key": self.key, 
                    "value": self.value, 
                    'MID': self.MID, 
                    'src': self.dst
                }
            })
            # server.controller.restartHeartbeat() # Sends one at a time? No batching?
        else:
            ## forward message to the leader
            return [ForwardMessage(self.dst, self.MID)] 

class PutResponse(ClientRPC):
    def __init__(self, dst: str, mid: str, MID: str, key: str):
        super().__init__(dst, 'ok', MID, key)
    
    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'leader': leader,
            'type': self.msg_type,
            'MID': self.MID
        })

class AppendEntriesResponse(ServerRPC):
    success: bool
    matchIndex: int

    def __init__(self, src, success, term, matchIndex):
        super().__init__(term, src, 'aer')
        self.success = success
        self.matchIndex = matchIndex
    
    def median(self, l: List):
        l = sorted(l)
        return l[math.floor(len(l) / 2)]
        
        

    def handleMessage(self, server):
        super().handleMessage(server)
        if self.success:
            server.state.nextIndex[self.dst] = self.matchIndex + 1
            server.state.matchIndex[self.dst] = self.matchIndex
            if server.controller.name == "leader":
                majorityCommitted = self.median(server.state.matchIndex.values())
                if majorityCommitted > server.state.commitIndex:
                    oldCommitIndex = server.state.commitIndex
                    server.state.commitIndex = majorityCommitted
                    server.controller.applyRules()
                    responses = []
                    for entry in server.state.log[oldCommitIndex:server.state.commitIndex]:
                        data = entry['data']
                        responses.append(GetResponse(data['MID'], data['src'], data['key'], data['value']))
                    return responses
        else:
            server.state.nextIndex[self.dst] = max(server.state.nextIndex[self.dst] - 1, 0)

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            "type": "aer",
            "success": self.success,
            'leader': leader,
            "term": self.term,
            'matchIndex': self.matchIndex }) 

class AppendEntries(ServerRPC):
    prevLogIndex : int
    prevLogTerm : int
    leaderCommit: int
    entries : List

    def __init__(self, src, prevLogIndex, prevLogTerm, leaderCommit, entries, term):
        super().__init__(term, src, 'ae')
        self.prevLogIndex = prevLogIndex
        self.prevLogTerm = prevLogTerm
        self.entries = entries
        self.leaderCommit = leaderCommit
    
    def handleMessage(self, server):
        """
        Handles an AppendEntries RPC and Sends a Response
        """
        if (server.controller.name == 'candidate' and self.term >= server.state.currentTerm):
            server.changeController('follower')
        super().handleMessage(server)
        if server.controller.name == "leader":
            print("Leader received an append entries")
            return None
        term_match: bool = self.term >= server.state.currentTerm
        if term_match: 
            server.controller.restartElectionTimeout()
            server.state.leader_id = self.dst
        entry_match: bool = self.prevLogTerm is None or (len(server.state.log) > self.prevLogIndex and self.prevLogTerm == server.state.log[self.prevLogIndex - 1]['term'])
        success = term_match and entry_match

        if success and server.controller.name == "follower": 
            if server.state.commitIndex > self.prevLogIndex: # if this server's log is different from leaders
                server.state.log = server.state.log[:self.prevLogIndex + 1] # remove all different
            server.state.log += self.entries # add all from leader
            if self.leaderCommit > server.state.commitIndex: # raft paper: AppendEntries: #5
                server.state.commitIndex = min(self.leaderCommit, len(server.state.log))

            server.event_loop.call_soon(server.controller.applyRules)
        return [AppendEntriesResponse(self.dst, success, server.state.currentTerm, len(server.state.log))]

class RequestVoteResponse(ServerRPC):
    """
    A response to a RequestVote.
    """
    voteGranted: bool
    
    def __init__(self, src, term, voteGranted: bool) -> None:
        super().__init__(term, src, 'rvr')
        self.voteGranted = voteGranted

    def handleMessage(self, server):
        super().handleMessage(server)
        if server.controller.name == 'candidate' and self.voteGranted:
            server.controller.votesReceived += 1
            server.log("VoteGranted: " + str(self.voteGranted) + " VotesReceived: " + str(server.controller.votesReceived))
            if(server.controller.votesReceived > server.majority):
                server.changeController('leader')

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'term': self.term,
            'type': self.msg_type,
            'leader': leader,
            'voteGranted': self.voteGranted
        })
    
class RequestVote(ServerRPC):
    candidateId : int
    lastLogIndex : int
    lastLogTerm : int

    def __init__(self, candidateId, lastLogIndex, lastLogTerm, term):
        super().__init__(term, candidateId, 'rv')
        self.dst = candidateId
        self.candidateId = candidateId
        self.lastLogTerm = lastLogTerm
        self.lastLogIndex = lastLogIndex

    def handleMessage(self, server) -> RequestVoteResponse:
        """
        Handles a Request Vote Message
        """
        super().handleMessage(server)

        serverLastLogTerm = server.state.log[-1]['term'] if server.state.log else 0
        length = len(server.state.log) if server.state.log else -1
        #termCheck = server.state.log[self.lastLogIndex - 1]['term'] if server.state.log else 0
        termCheck = self.lastLogTerm > serverLastLogTerm
        indexCheck = self.lastLogTerm == serverLastLogTerm and self.lastLogIndex >= length
        upToDate = termCheck or indexCheck
        server.log("| TermCheck: " + str(termCheck) + "| IndexCheck: " + str(indexCheck) + "| UPTODATE: " + str(upToDate))
        voteGranted = self.term >= server.state.currentTerm \
            and server.state.votedFor in [None, self.candidateId] \
                and upToDate
        if voteGranted:
            server.controller.restartElectionTimeout()
            server.state.votedFor = self.candidateId
        resp = RequestVoteResponse(self.candidateId, server.state.currentTerm, voteGranted)
        server.log("sending RVResponse" + resp.toJSON(server.state.id, server.state.leader_id))
        return [resp]

class Controller:
    name: str
    election_timeout: asyncio.TimerHandle
    server = None
    
    def __init__(self, name, server):
        self.server = server
        self.name = name
        server.state.leader_id = 'FFFF'
        self.election_timeout = None

    def restartElectionTimeout(self):
        if self.election_timeout is not None:
            self.election_timeout.cancel()
        timeout = random.randint(150, 200) / 1000
        self.election_timeout = self.server.event_loop.call_later(timeout, self.server.changeController, "candidate")
        

    def applyRules(self):
        #print("Applying from " + str(self.server.state.lastApplied) + " to " + str(self.server.state.commitIndex) + " log size: " + str(len(self.server.state.log)))
        while self.server.state.commitIndex > self.server.state.lastApplied:
            self.server.state.lastApplied += 1
            toAdd = self.server.state.log[self.server.state.lastApplied - 1]["data"]
            self.server.data[toAdd["key"]] = toAdd["value"]
            
class Leader(Controller):
    heartbeat: asyncio.TimerHandle
    commitCount : int

    def __init__(self, server) -> None:
        super().__init__("leader", server)
        server.log("Became a leader")
        self.server.state.leader_id = self.server.state.id
        self.server.state.matchIndex = { replica: 0 for replica in server.state.replicas }
        self.server.state.nextIndex = { replica: server.state.commitIndex + 1 for replica in server.state.replicas }
        self.heartbeat = None
        self.restartHeartbeat()
        self.commitCount = 0

    def restartHeartbeat(self):
        if self.heartbeat is not None:
            self.heartbeat.cancel()
        #self.server.log("Leader LOG: " + json.dumps(self.server.state.log))
        [self.server.event_loop.create_task(self.sendAEMessage(replica)) for replica in self.server.state.replicas]
        timeout = random.randint(50, 60) / 1000
        self.heartbeat = self.server.event_loop.call_later(timeout, self.restartHeartbeat)

    async def sendAEMessage(self, replica_id):
        nextIndex = self.server.state.nextIndex[replica_id] - 1
        await self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            "type": "ae",
            "term": self.server.state.currentTerm,
            "src": self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            "entries" : self.server.state.log[nextIndex: nextIndex + 50], # TODO batch
            "leaderCommit" : self.server.state.commitIndex,
            'prevLogIndex': nextIndex - 1,
            'prevLogTerm': self.server.state.log[nextIndex - 1]['term'] if nextIndex > 0 and len(self.server.state.log) >= nextIndex else None 
        }).encode())

    def restartElectionTimeout(self):
        print("Leaders don't have election timeout")
    
class Candidate(Controller):
    votesReceived: int
    
    def __init__(self, server) -> None:
        super().__init__("candidate", server)
        self.server.state.leader_id = 'FFFF' # TODO is this necessary
        self.server.state.currentTerm += 1
        server.log("Became a Candidate at term " + str(server.state.currentTerm))
        self.server.state.votedFor = self.server.state.id
        self.votesReceived = 1
        [self.server.event_loop.create_task(self.sendRV(replica_id)) for replica_id in self.server.state.replicas]
        self.restartElectionTimeout()

    async def sendRV(self, replica_id):
        await self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            'src': self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            'term': self.server.state.currentTerm,
            'type': 'rv',
            'lastLogIndex': len(self.server.state.log) - 1,
            'lastLogTerm': self.server.state.log[-1]['term'] if self.server.state.log else 0
        }).encode())

class Follower(Controller):
    
    def __init__(self, server) -> None:
        super().__init__("follower", server)
        server.log("Became a follower")
        self.restartElectionTimeout()

class Server:
    state: State
    controller: Controller
    rpcfactory: RPCFactory
    sock: socket.socket
    data: Dict
    event_loop = None
    majority: int

    def log(self, message, dest=None):
        if DEBUG:
            message = f'[{round(time.time() * 1000)}][Host: {self.state.id}] {message} {"[To: " + dest + "]" if dest else ""}\n'
            self.logFile.write(message)
            #print(message)

    def __init__(self, my_id, replicas, sock):
        self.state = State(my_id, replicas)
        if DEBUG:
            self.logFile = open("output" + self.state.id + ".txt", "w")
        self.rpcfactory = RPCFactory()
        self.sock = sock
        self.majority = (len(replicas) + 1) / 2
        self.data = {}
        self.event_loop = asyncio.get_event_loop()
        asyncio.get_event_loop().create_task(self.receive())
        self.event_loop.set_debug(True) # TODO remove
        self.controller = Follower(self)
        self.event_loop.run_forever()

    async def receive(self):
        msg_raw = await self.event_loop.sock_recv(self.sock, 32768)
        if len(msg_raw) != 0:
            msg = json.loads(msg_raw)
            rpc = self.rpcfactory.BuildMessage(msg)
            self.log("HOST RECEIVED: " + json.dumps(msg))
            responses = rpc.handleMessage(self)
            if responses is not None:
                for resp in responses:
                    if resp.msg_type == 'redirect':
                        self.log("Forwarding message to " + resp.dst)
                    self.sock.send(resp.toJSON(self.state.id, self.state.leader_id).encode())  
        asyncio.get_event_loop().create_task(self.receive())

    def changeController(self, controller_type: str):
        if self.controller.election_timeout is not None:
            self.controller.election_timeout.cancel()
        if self.controller.name == 'leader' and self.controller.heartbeat is not None:
            self.controller.heartbeat.cancel()
        if controller_type == "candidate": # TODO check if the candidate is up to date:
            self.controller = Candidate(self)
        elif controller_type == 'follower':
            self.controller = Follower(self)
        elif controller_type == 'leader':
            self.controller = Leader(self)
        

if __name__ == "__main__":
    # Your ID number
	my_id = sys.argv[1]

	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]

	# Connect to the network. All messages to/from other replicas and clients will
	# occur over this socket
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	sock.setblocking(0)
	sock.connect(my_id)
    
	Server(my_id, replica_ids, sock)
