#!/usr/bin/env python3

import sys, socket, select, time, json, random, asyncio
from typing import List

DEBUG = True

class Database:
	db = None
	def __init__(self):
		self.db = {}

	def put(self, key, value):
		self.db[key] = value
	
	def get(self, key):
		if key in self.db:
			return self.db[key]

class LogEntry:
	entryType: str
	
	def __init__(self, entryType, ):
		self.entryType = entryType

class Server:
	# persistent data
	id: int # id of this server
	replica_ids: List[int] # replica ids
	currentTerm: int # current term of this server
	logEntries: List[LogEntry] # logentries
	votedFor: int # who this server votedfor this term

	# volatile data
	commitIndex: int # last committed log entry index
	lastApplied: int # last applied log entry index
	state: str # one of "follower", "leader", "candidate"
	votesReceived: int # number of votes received this term
	leader_id: int

	# communcation and event management objects
	sock: socket.socket # socket
	event_loop = None # asyncio loop
	election_timeout: asyncio.TimerHandle = None # asyncio call_later object to handle election timeout
	heartbeat: asyncio.TimerHandle = None # asyncio call_later object to handle heartbeat

	# cache requests during election
	requests: List

	def __init__(self, my_id: int, replica_ids: List[int], sock: socket.socket):
		self.id = my_id
		self.replica_ids = replica_ids
		self.currentTerm = self.commitIndex = self.lastApplied = 0
		self.votedFor = None
		self.state = "follower"
		self.sock = sock
		self.leader_id = 'FFFF'
		self.requests = []
		self.logEntries = []

		self.event_loop = asyncio.get_event_loop()
		self.restartElectionTimeout()
		self.event_loop.create_task(self.receive())
		self.event_loop.run_forever()
		pass

	def log(self, message, dest=None):
		print(f'[{round(time.time() * 1000)}][Host: {self.id}] {message} {"[To: " + dest + "]" if dest else ""}')

	async def receive(self):
		msg_raw = await self.event_loop.sock_recv(self.sock, 32768)
		if len(msg_raw) == 0:
			pass
		else:
			msg = json.loads(msg_raw)
			# For now, ignore get() and put() from clients
			if msg['type'] in ['get', 'put']:
				if self.state == "leader":
					self.processRequest()
				elif self.state == "candidate":
					self.requests.append(msg)
				else:
					self.event_loop.call_soon(self.forwardMessage(msg))
			
			# Handle RequestVote messages. If follower has not voted for anyone this term, send a vote back.
			elif msg['type'] == 'rv':
				self.log("Received RV Message [FROM: " + msg['src'] + "]")
				if msg['term'] > self.currentTerm:
					self.restartElectionTimeout()
					self.becomeFollower(msg['term'], msg['leader'])
				if msg['term'] == self.currentTerm and self.votedFor in [None, msg['src']]:
					self.restartElectionTimeout()
					self.sendVoteMessage(msg['src'])
	
			# Handle Vote messages
			elif msg['type'] == 'vote':
				if self.state != 'leader' and msg['term'] == self.currentTerm:
					self.votesReceived += 1
					if self.votesReceived > len(replica_ids) / 2:
						self.election_timeout.cancel()
						self.becomeLeader()
				elif msg['term'] > self.currentTerm:
					self.restartElectionTimeout()
					self.becomeFollower(msg['term'], msg['leader'])

			elif msg['type'] == 'ae':
				self.log("Received AE Message [FROM: " + msg['src'] + "]")
				if msg['term'] >= self.currentTerm:
					self.restartElectionTimeout()
					
					# we can only have one leader, so if someone (Joe Biden) is already sending AppendEntry messages, concede to Joe Biden
					if self.state != 'follower':
						self.becomeFollower(msg['term'], msg['leader'])

					# TODO: Checking log indexes
					self.appendEntries(msg['entries'], msg['commitIndex'])
					
				else:
					self.log("Append Entries discarded. Term is lower than Current.")
		self.event_loop.create_task(self.receive())


	#State change methods
	def becomeCandidate(self):
		self.log("Became a candidate")
		self.state = "candidate"
		self.currentTerm += 1
		self.votedFor = self.id
		self.votesReceived = 0
		requests = [self.event_loop.create_task(self.sendRVMessage(replica_id)) for replica_id in replica_ids]
		asyncio.wait(requests) # TODO: This needs to have a timeout
	
	def becomeFollower(self, term, leader):
		if self.heartbeat is not None:
			self.heartbeat.cancel()
		self.leader_id = leader
		self.currentTerm = term
		self.votedFor = None
		if self.state != 'follower':
			self.state = "follower"
			self.log("Became a follower")
		if len(self.requests):
			requests = [self.event_loop.create_task(self.forwardMessage(msg)) for msg in self.requests]
			asyncio.wait(requests) 
			self.requests = []

	def becomeLeader(self):
		self.log("Became the leader")
		self.state = "leader"
		self.sendHeartbeat()

	# Timed Callbacks
	def sendHeartbeat(self):
		#TODO Add any entries that need to be logged
		requests = [self.event_loop.create_task(self.sendAEMessage(replica_id)) for replica_id in replica_ids]
		asyncio.wait(requests) # TODO: This needs to have a timeout
		self.heartbeat = self.event_loop.call_later(0.05, self.sendHeartbeat)
	
	def restartElectionTimeout(self):
		timeout = random.randint(150, 300) / 1000
		#self.log("Timeout restarted to : " + str(timeout))
		if self.election_timeout != None: 
			self.election_timeout.cancel()
		self.election_timeout = self.event_loop.call_later(timeout, self.becomeCandidate)

	# Send Message methods
	async def sendAEMessage(self, dest):
		self.log("Sending AE Message", dest=dest)
		message = { 'src': self.id, 'dst': dest, 'leader': self.id, 'type': 'ae', 'term': self.currentTerm }
		self.sock.sendall(json.dumps(message).encode())

	async def sendRVMessage(self, dest):
		self.log("Sending RV Message", dest=dest)
		message = {'src': self.id, 'dst': dest, 'leader': self.leader_id, 'type': 'rv', 'term': self.currentTerm }
		self.sock.sendall(json.dumps(message).encode())

	def sendVoteMessage(self, dest):
		self.log("Sending Vote", dest=dest)
		self.votedFor = dest
		message = {'src': self.id, 'dst': dest, 'leader': self.leader_id, 'type': 'vote', 'term': self.currentTerm }
		self.sock.sendall(json.dumps(message).encode())

	def forwardMessage(self, msg):
		self.log("Forwarding Message", dest=self.leader_id)
		msg['dst'] = self.leader_id
		self.sock.sendall(json.dumps(msg).encode())

	def processRequest(self, request):
		#TODO process cached entries
		pass

	def appendEntries(self, entries, commitIndex):
		self.logEntries += entries
		for entry in self.logEntries[self.commitIndex:commitIndex]:
			self.applyEntry(entry)
		self.commitIndex = commitIndex

	def self.applyEntry(self, entry):
		pass


if __name__ == "__main__":
	# Your ID number
	my_id = sys.argv[1]

	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]

	# Connect to the network. All messages to/from other replicas and clients will
	# occur over this socket
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	sock.connect(my_id)

	Server(my_id, replica_ids, sock)
	