#!/usr/bin/env python3

import sys, socket, select, time, json, random, asyncio
from typing import List, Dict

class Server:
    pass

class State:
    id: str
    replicas: List
    # Persistent state on all servers
    currentTerm: int
    votedFor: str
    log: List
    leader_id: str
    # Volitile state on all servers
    commitIndex: int
    lastApplied: int
    # Volitile state on all servers
    nextIndex : Dict
    matchIndex : Dict

    def __init__(self, my_id, replica_ids):
        self.id = my_id
        self.replicas = replica_ids
        self.nextIndex = { replica: 0 for replica in replica_ids }
        self.matchIndex = { replica: 0 for replica in replica_ids }
        self.leader_id = 'FFFF'
        self.votedFor = None
        self.log = []
        self.commitIndex = self.lastApplied = self.currentTerm = 0

class RPC:
    dst: str
    msg_type: str

    def __init__(self, dst, msg_type):
        self.dst = dst
        self.msg_type = msg_type

class ClientRPC(RPC):
    MID: str
    key: str
    
    def __init__(self, dst, msg_type, MID, key):
        super().__init__(dst, msg_type)
        self.MID = MID
        self.key = key

class ServerRPC(RPC):
    term : int

    def __init__(self, term, dst, msg_type):
        super().__init__(dst, msg_type)
        self.term = term

class RPCFactory:
    def BuildMessage(self, msg) -> RPC:
        """
        Builds message from JSON response.
        """
        if msg["type"] == "rv":
            return RequestVote(msg['src'], msg['lastLogIndex'], msg['lastLogTerm'], msg['term'])
        elif msg['type'] == 'ae':
            return AppendEntries(msg['src'], msg['prevLogIndex'], msg['prevLogTerm'], msg['leaderCommit'], msg['entries'], msg['term'])
        elif msg['type'] == 'aer':
            return AppendEntriesResponse(msg['src'], msg['success'], msg['term'], msg['matchIndex'])
        elif msg['type'] == 'rvr':
            return RequestVoteResponse(msg['src'], msg['voteGranted'], msg['term'])
        elif msg['type'] == 'get':
            return Get(msg['src'], msg['key'], msg['term'])
        elif msg['type'] == 'put':
            return Put(msg['src'], msg['key'], msg['value'], msg['MID'])
        else:
            raise RuntimeError("Got MSG Type:" + msg['type'])

class ForwardMessage(ClientRPC):
    def __init__(self, dst, MID):
        super().__init__(dst, 'redirect', MID, None)

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'leader': leader,
            'MID': self.MID,
            'type': self.msg_type,
        })

class Get(ClientRPC):
    """
    A Get request
    """
    def __init__(self, src, key, MID):
        super().__init__(src, "get", MID, key)

    def handleMessage(self, server: Server):
        if self.leader != server.leader:
            ## forward message to the leader
            return ForwardMessage(self.dst, self.MID)
        else:
            return GetResponse(self.MID, self.dst, self.key, server.data[self.key] if self.key in server.data else "")

class GetResponse(ClientRPC):
    value: str
    def __init__(self, mid : str, dst : str, key : str, value : str):
        super().__init__(src, "ok", mid, key)
        self.value = value

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            "leader": leader,
            "type" : self.msg_type,
            "MID" : self.MID,
            "value" : self.value
        })

class Put(ClientRPC):
    
    def __init__(self, src, key, value, MID):
        super().__init__(src, 'put', MID, key)
        self.value = value

    def handleMessage(self, server):
        server.state.log.append({ 
            'entryType': 'put', 
            'term': server.state.currentTerm,
            'index': len(server.state.log), 
            'data': {
                "key": self.key, 
                "value": self.value, 
                'MID': self.MID, 
                'src': self.dst
            }
        })
        return None

class PutResponse(ClientRPC):
    def __init__(self, dst: str, mid: str, MID: str, key: str):
        super().__init__(dst, 'ok', MID, key)
    
    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'leader': leader,
            'type': self.msg_type,
            'MID': self.MID,
            'value': self.value
        })

class AppendEntriesResponse(ServerRPC):
    success: bool
    matchIndex: int

    def __init__(self, src, success, term, matchIndex):
        super().__init__(term, src, 'aer')
        self.success = success
        self.matchIndex = matchIndex

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            "type": "aer",
            "success": self.success,
            'leader': leader,
            "term": self.term,
            'matchIndex': self.matchIndex }) 

class AppendEntries(ServerRPC):
    prevLogIndex : int
    prevLogTerm : int
    leaderCommit: int
    entries : List

    def __init__(self, src, prevLogIndex, prevLogTerm, leaderCommit, entries, term):
        super().__init__(term, src, 'ae')
        self.prevLogIndex = prevLogIndex
        self.prevLogTerm = prevLogTerm
        self.entries = entries
        self.leaderCommit = leaderCommit
    
    def handleMessage(self, server):
        """
        Handles an AppendEntries RPC and Sends a Response
        """
        term_match = server.state.currentTerm.term  >= server.state.commitIndex
        prev_term_match = self.prevLogTerm in [server.state.log[self.prevLogIndex], None]
        success = not term_match and prev_term_match

        if not success:
            return AppendEntriesResponse(self.dst, success, self.term, len(server.state.log))
        else:
            if len(server.state.log) > self.prevLogIndex:
                server.state.log = server.state.log[:self.prevLogIndex]
            server.state.log += self.entries

            if self.leaderCommit > server.state.commitIndex:
                server.state.commitIndex = min(self.leaderCommit, len(server.state.log) - 1)

class RequestVoteResponse(ServerRPC):
    """
    A response to a RequestVote.
    """
    voteGranted: bool
    
    def __init__(self, src, term, voteGranted: bool) -> None:
        super().__init__(term, src, 'rvr')
        self.voteGranted = voteGranted

    def handleMessage(self, server):
        if server.controller.name == 'candidate':
            server.controller.votesReceived += 1
            if(server.controller.votesReceived > server.majority):
                server.changeController('leader')

    def toJSON(self, src, leader):
        return json.dumps({
            'src': src,
            'dst': self.dst,
            'term': self.term,
            'type': self.msg_type,
            'leader': leader,
            'voteGranted': self.voteGranted
        })
    
class RequestVote(ServerRPC):
    candidateId : int
    lastLogIndex : int
    lastLogTerm : int

    def __init__(self, candidateId, lastLogIndex, lastLogTerm, term):
        super().__init__(term, candidateId, 'rv')
        self.dst = candidateId
        self.candidateId = candidateId
        self.lastLogTerm = lastLogTerm

    def handleMessage(self, server) -> RequestVoteResponse:
        """
        Handles a Request Vote Message
        """
        voteGranted = self.term >= server.state.currentTerm \
            or (server.state.votedFor in [None, self.candidateId]
                and self.lastLogTerm == server.state.log[-1]["term"]) 
        return RequestVoteResponse(server.state.id, server.state.currentTerm, voteGranted)

class Controller:
    name: str
    election_timeout: asyncio.TimerHandle
    server = None
    
    def __init__(self, name, server):
        self.server = server
        self.name = name
        self.election_timeout = None

    def restartElectionTimeout(self):
        if self.election_timeout is not None:
            self.election_timeout.cancel()
        timeout = random.randint(60, 150) / 1000
        self.server.event_loop.call_later(timeout, self.server.changeController, "candidate")
        

    def applyRules(self):
        if self.server.state.commitIndex > self.server.state.lastApplied:
            self.server.state.lastApplied += 1
            toAdd = self.server.state.log[self.server.state.lastApplied]
            self.server

class Leader(Controller):
    heartbeat: asyncio.TimerHandle

    def __init__(self, server) -> None:
        super().__init__("leader", server)
        self.heartbeat = None
        self.restartHeartbeat()

    def restartHeartbeat(self):
        if self.heartbeat is not None:
            self.heartbeat.cancel()
        [self.server.event_loop.create_task(self.sendAEMessage(replica)) for replica in self.server.state.replicas]
        timeout = random.randint(30, 50) / 1000
        self.server.event_loop.call_later(timeout, self.restartHeartbeat)

    async def sendAEMessage(self, replica_id):
        nextIndex = self.server.state.nextIndex[replica_id]
        self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            "type": "ae",
            "term": self.server.state.currentTerm,
            "src": self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            "entries" : self.server.state.log[nextIndex:nextIndex + 50],
            "leaderCommit" : self.server.state.commitIndex,
            'prevLogindex': nextIndex - 1,
            'prevLogTerm': self.server.state.log[nextIndex - 1]['term']
        }))

    def restartElectionTimeout(self):
        print("Leaders don't have election timeout")
    
class Candidate(Controller):
    votesReceived: int
    
    def __init__(self, server) -> None:
        super().__init__("candidate", server)
        self.server.state.leader_id = 'FFFF' # TODO is this necessary
        self.server.state.currentTerm += 1
        self.server.state.votedFor = self.server.state.id
        self.votesReceived = 1
        [self.server.event_loop.create_task(self.sendRV(replica_id)) for replica_id in self.server.state.replicas]
        self.restartElectionTimeout()

    async def sendRV(self, replica_id):
        self.server.event_loop.sock_sendall(self.server.sock, json.dumps({
            'src': self.server.state.id,
            'dst': replica_id,
            'leader': self.server.state.leader_id,
            'term': self.server.state.currentTerm,
            'type': 'rv',
            'lastLogIndex': len(self.server.state.log) - 1,
            'lastLogTerm': self.server.state.log[-1]['term'] if self.server.state.log else None
        }).encode())

class Follower(Controller):
    
    def __init__(self, server) -> None:
        super().__init__("follower", server)
        self.restartElectionTimeout()

class Server:
    state: State
    controller: Controller
    rpcfactory: RPCFactory
    sock: socket.socket
    data: Dict
    event_loop = None
    majority: int

    def __init__(self, my_id, replicas, sock):
        self.id = my_id
        self.state = State(my_id, replicas)
        self.rpcfactory = RPCFactory()
        self.sock = sock
        self.majority = (len(replicas) + 1) / 2
        self.event_loop = asyncio.get_event_loop()
        asyncio.get_event_loop().create_task(self.receive())
        self.event_loop.set_debug(True) # TODO remove
        self.controller = Follower(self)
        self.event_loop.run_forever()

    async def receive(self):
        msg_raw = await self.event_loop.sock_recv(self.sock, 32768)
        if len(msg_raw) != 0:
            msg = json.loads(msg_raw)
            rpc = self.rpcfactory.BuildMessage(msg)
            print("RPC: " + str(rpc))
            resp = rpc.handleMessage(self)
            if resp is not None:
                self.event_loop.sock_sendall(self.sock, resp.toJSON(self.state.id, self.state.leader_id).encode())  
        asyncio.get_event_loop().create_task(self.receive())

    def changeController(self, controller_type: str):
        if controller_type == "candidate":
            self.controller = Candidate(self)
        elif controller_type == 'follower':
            self.controller = Follower(self)
        elif controller_type == 'leader':
            self.controller = Leader(self)
        

if __name__ == "__main__":
    # Your ID number
	my_id = sys.argv[1]

	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]

	# Connect to the network. All messages to/from other replicas and clients will
	# occur over this socket
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	sock.setblocking(0)
	sock.connect(my_id)
    
	Server(my_id, replica_ids, sock)
