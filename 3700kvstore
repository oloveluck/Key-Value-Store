#!/usr/bin/env python3

import sys, socket, select, time, json, random, asyncio
from typing import List

DEBUG = True

class LogEntry:
	pass

class Server:
	# persistent data
	id: int # id of this server
	replica_ids: List[int] # replica ids
	currentTerm: int # current term of this server
	log: List[LogEntry] # logentries
	votedFor: int # who this server votedfor this term

	# volatile data
	commitIndex: int # last committed log entry index
	lastApplied: int # last applied log entry index
	state: str # one of "follower", "leader", "candidate"

	# communcation and event management objects
	sock: socket.socket # socket
	event_loop = None # asyncio loop
	timeout: asyncio.TimerHandle = None # asyncio call_later object to handle timeout

	def __init__(self, my_id: int, replica_ids: List[int], sock: socket.socket):
		self.id = my_id
		self.replica_ids = replica_ids
		self.currentTerm = self.commitIndex = self.lastApplied = 0
		self.state: "follower"
		self.event_loop = asyncio.get_event_loop()
		self.sock = sock
		self.startTimeout()
		self.event_loop.create_task(self.receive())
		self.event_loop.run_forever()
		pass

	async def receive(self):
		msg_raw = await self.event_loop.sock_recv(self.sock, 32768)
		if len(msg_raw) == 0:
			pass
		else:
			msg = json.loads(msg_raw)
			# For now, ignore get() and put() from clients
			if msg['type'] in ['get', 'put']:
				pass
			
			# Handle noop messages. This may be removed from your final implementation
			elif msg['type'] == 'noop':
				print(f'{msg["dst"]} received a NOOP from {msg["src"]}')

			elif msg['type'] == 'rv':
				print(msg)
		self.event_loop.create_task(self.receive())


	def startTimeout(self):
		timeout = random.randint(150, 300) / 1000
		if self.timeout != None: 
			self.timeout.cancel()
		self.timeout = self.event_loop.call_later(timeout, self.beginElection)

	def beginElection(self):
		print("Beginning Election on host " + self.id)
		self.currentTerm += 1
		requests = [self.event_loop.create_task(self.sendRVMessage(replica_id)) for replica_id in replica_ids]
		asyncio.gather(*requests)
		pass

	async def sendRVMessage(self, dest):
		print("Sending RV Message")
		message = {'src': self.id, 'dst': dest, 'leader': 'FFFF', 'type': 'rv' }
		self.sock.sendall(json.dumps(message).encode())

	async def appendEntries(self):
		pass

# while True:
# 	ready = select.select([sock], [], [], 0.1)[0]
		
# 	clock = time.time()
# 	if clock-last > 2:
# 		# Send a no-op message to a random peer every two seconds, just for fun
# 		# You definitely want to remove this from your implementation
# 		msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
# 		sock.send(json.dumps(msg))
# 		print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
# 		last = clock

if __name__ == "__main__":
	# Your ID number
	my_id = sys.argv[1]

	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]

	# Connect to the network. All messages to/from other replicas and clients will
	# occur over this socket
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
	sock.connect(my_id)

	Server(my_id, replica_ids, sock)
	